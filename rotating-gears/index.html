<!DOCTYPE html>
<html>
<head>
    <meta charset=utf-8>
    <title>PRIME interactive</title>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }

        body {
            margin: 0;
            display: flex;
            align-items: stretch;
        }

        canvas {
            width: 100%;
            height: 100%
        }

        #matrix {
            width: 300px;
            height: 100px;
            position: absolute;
            right: 0;
            bottom: 0;
            background: black;
            color: #ffce2e ;
        }

        #matrix div {
            alignment: center;
            position: absolute;
        }

        .matrix:before, .matrix:after {
            content: "";
            position: absolute;
            top: 0;
            border: 1px solid #7ab1e8;
            width: 6px;
            height: 100%;
        }
        .matrix:before {
            left: -6px;
            border-right: 0px;
        }
        .matrix:after {
            right: -6px;
            border-left: 0px;
        }
        .matrix td {
            padding: 5px;
            text-align: center;
        }

    </style>
</head>
<body>
<canvas id="glCanvas">
</canvas>
<div id="matrix">
    <div align=center>
        <table class="matrix">
            <tr>
                <td>cos(<span class="angle">T</span>)</td>
                <td>-sin(<span class="angle">T</span>)</td>
            </tr>
            <tr>
                <td>sin(<span class="angle">T</span>)</td>
                <td>cos(<span class="angle">T</span>)</td>
            </tr>
        </table>
    </div>
</div>
</body>
<script src="../js/webgl-obj-loader.js"></script>
<script id="vertex-shader" type="not-javascript">
// Per-vertex attributes
attribute vec3 pos; // World-space position
attribute vec3 norm; // World-space position

uniform mat3 scaleToScreen;
uniform mat3 rotation;
varying highp vec3 fragNorm;

void main() {
	// Transform 3D position into on-screen position
	gl_Position = (vec4(scaleToScreen*rotation*pos, 1.0));
	fragNorm = norm;

}
</script>
<script id="fragment-shader" type="not-javascript">

varying highp vec3 fragNorm;
uniform bool renderLines;

void main() {
	// output
	if(renderLines) {
	        gl_FragColor = vec4(0.48, 0.69, 0.91, 1.0); //make helplines blue
	}
    else if(abs(fragNorm).z > 0.9) {
        gl_FragColor = vec4(0.81, 0.78, 0.75, 1.0); //make planes gray
    }
    else {
        gl_FragColor = vec4(1.0, 0.81, 0.18, 1.0); // make edges yellow
    }
}
</script>
<script id="circle-vertex-shader" type="not-javascript">
// Per-vertex attributes
attribute vec3 pos; // World-space position
uniform mat3 scaleToScreen;

void main() {
	// Transform 3D position into on-screen position
	gl_Position = (vec4(scaleToScreen*pos, 1.0));

}
</script>
<script id="circle-fragment-shader" type="not-javascript">

void main() {
	// output
    gl_FragColor = vec4(0.48, 0.69, 0.91, 1.0);
}
</script>
<script src="../js/gl-matrix.js"></script>
<script src="../js/webgl-utils.js"></script>
<script src="../js/vector-math.js"></script>
<script src="webglfunctions.js"></script>
<script src="main.js"></script>
</html>